// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/asset"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/plugin"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/pluginversion"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/pluginversionproperty"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/predicate"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/project"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/storage"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/storagecommit"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/storageplugin"
	"github.com/khorevaa/r2gitsync/internal/services/db/ent/storagepluginproperty"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAsset                 = "Asset"
	TypePlugin                = "Plugin"
	TypePluginVersion         = "PluginVersion"
	TypePluginVersionProperty = "PluginVersionProperty"
	TypeProject               = "Project"
	TypeStorage               = "Storage"
	TypeStorageCommit         = "StorageCommit"
	TypeStoragePlugin         = "StoragePlugin"
	TypeStoragePluginProperty = "StoragePluginProperty"
)

// AssetMutation represents an operation that mutates the Asset nodes in the graph.
type AssetMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	file_name     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Asset, error)
	predicates    []predicate.Asset
}

var _ ent.Mutation = (*AssetMutation)(nil)

// assetOption allows management of the mutation configuration using functional options.
type assetOption func(*AssetMutation)

// newAssetMutation creates new mutation for the Asset entity.
func newAssetMutation(c config, op Op, opts ...assetOption) *AssetMutation {
	m := &AssetMutation{
		config:        c,
		op:            op,
		typ:           TypeAsset,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssetID sets the ID field of the mutation.
func withAssetID(id uuid.UUID) assetOption {
	return func(m *AssetMutation) {
		var (
			err   error
			once  sync.Once
			value *Asset
		)
		m.oldValue = func(ctx context.Context) (*Asset, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Asset.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAsset sets the old Asset of the mutation.
func withAsset(node *Asset) assetOption {
	return func(m *AssetMutation) {
		m.oldValue = func(context.Context) (*Asset, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Asset entities.
func (m *AssetMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssetMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssetMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Asset.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[asset.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[asset.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, asset.FieldDeletedAt)
}

// SetFileName sets the "file_name" field.
func (m *AssetMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *AssetMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the Asset entity.
// If the Asset object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssetMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ResetFileName resets all changes to the "file_name" field.
func (m *AssetMutation) ResetFileName() {
	m.file_name = nil
}

// Where appends a list predicates to the AssetMutation builder.
func (m *AssetMutation) Where(ps ...predicate.Asset) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Asset).
func (m *AssetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssetMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, asset.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, asset.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, asset.FieldDeletedAt)
	}
	if m.file_name != nil {
		fields = append(fields, asset.FieldFileName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case asset.FieldCreatedAt:
		return m.CreatedAt()
	case asset.FieldUpdatedAt:
		return m.UpdatedAt()
	case asset.FieldDeletedAt:
		return m.DeletedAt()
	case asset.FieldFileName:
		return m.FileName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case asset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case asset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case asset.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case asset.FieldFileName:
		return m.OldFileName(ctx)
	}
	return nil, fmt.Errorf("unknown Asset field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case asset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case asset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case asset.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case asset.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Asset numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(asset.FieldDeletedAt) {
		fields = append(fields, asset.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssetMutation) ClearField(name string) error {
	switch name {
	case asset.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Asset nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssetMutation) ResetField(name string) error {
	switch name {
	case asset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case asset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case asset.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case asset.FieldFileName:
		m.ResetFileName()
		return nil
	}
	return fmt.Errorf("unknown Asset field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssetMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssetMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssetMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssetMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Asset unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssetMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Asset edge %s", name)
}

// PluginMutation represents an operation that mutates the Plugin nodes in the graph.
type PluginMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Plugin, error)
	predicates    []predicate.Plugin
}

var _ ent.Mutation = (*PluginMutation)(nil)

// pluginOption allows management of the mutation configuration using functional options.
type pluginOption func(*PluginMutation)

// newPluginMutation creates new mutation for the Plugin entity.
func newPluginMutation(c config, op Op, opts ...pluginOption) *PluginMutation {
	m := &PluginMutation{
		config:        c,
		op:            op,
		typ:           TypePlugin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPluginID sets the ID field of the mutation.
func withPluginID(id uuid.UUID) pluginOption {
	return func(m *PluginMutation) {
		var (
			err   error
			once  sync.Once
			value *Plugin
		)
		m.oldValue = func(ctx context.Context) (*Plugin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plugin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlugin sets the old Plugin of the mutation.
func withPlugin(node *Plugin) pluginOption {
	return func(m *PluginMutation) {
		m.oldValue = func(context.Context) (*Plugin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PluginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PluginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plugin entities.
func (m *PluginMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PluginMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PluginMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plugin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PluginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PluginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PluginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PluginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PluginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PluginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PluginMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PluginMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PluginMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[plugin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PluginMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[plugin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PluginMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, plugin.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PluginMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PluginMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PluginMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PluginMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PluginMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plugin entity.
// If the Plugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PluginMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the PluginMutation builder.
func (m *PluginMutation) Where(ps ...predicate.Plugin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PluginMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Plugin).
func (m *PluginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PluginMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, plugin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plugin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, plugin.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, plugin.FieldName)
	}
	if m.description != nil {
		fields = append(fields, plugin.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PluginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plugin.FieldCreatedAt:
		return m.CreatedAt()
	case plugin.FieldUpdatedAt:
		return m.UpdatedAt()
	case plugin.FieldDeletedAt:
		return m.DeletedAt()
	case plugin.FieldName:
		return m.Name()
	case plugin.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PluginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plugin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plugin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plugin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case plugin.FieldName:
		return m.OldName(ctx)
	case plugin.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Plugin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plugin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plugin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plugin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case plugin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plugin.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Plugin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PluginMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PluginMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Plugin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PluginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plugin.FieldDeletedAt) {
		fields = append(fields, plugin.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PluginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PluginMutation) ClearField(name string) error {
	switch name {
	case plugin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Plugin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PluginMutation) ResetField(name string) error {
	switch name {
	case plugin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plugin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plugin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case plugin.FieldName:
		m.ResetName()
		return nil
	case plugin.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Plugin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PluginMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PluginMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PluginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PluginMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PluginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PluginMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PluginMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Plugin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PluginMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Plugin edge %s", name)
}

// PluginVersionMutation represents an operation that mutates the PluginVersion nodes in the graph.
type PluginVersionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	version       *string
	description   *string
	broken        *bool
	clearedFields map[string]struct{}
	plugin        *uuid.UUID
	clearedplugin bool
	done          bool
	oldValue      func(context.Context) (*PluginVersion, error)
	predicates    []predicate.PluginVersion
}

var _ ent.Mutation = (*PluginVersionMutation)(nil)

// pluginversionOption allows management of the mutation configuration using functional options.
type pluginversionOption func(*PluginVersionMutation)

// newPluginVersionMutation creates new mutation for the PluginVersion entity.
func newPluginVersionMutation(c config, op Op, opts ...pluginversionOption) *PluginVersionMutation {
	m := &PluginVersionMutation{
		config:        c,
		op:            op,
		typ:           TypePluginVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPluginVersionID sets the ID field of the mutation.
func withPluginVersionID(id uuid.UUID) pluginversionOption {
	return func(m *PluginVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *PluginVersion
		)
		m.oldValue = func(ctx context.Context) (*PluginVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PluginVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPluginVersion sets the old PluginVersion of the mutation.
func withPluginVersion(node *PluginVersion) pluginversionOption {
	return func(m *PluginVersionMutation) {
		m.oldValue = func(context.Context) (*PluginVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PluginVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PluginVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PluginVersion entities.
func (m *PluginVersionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PluginVersionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PluginVersionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PluginVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PluginVersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PluginVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PluginVersion entity.
// If the PluginVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PluginVersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PluginVersionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PluginVersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PluginVersion entity.
// If the PluginVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PluginVersionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PluginVersionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PluginVersionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PluginVersion entity.
// If the PluginVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PluginVersionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pluginversion.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PluginVersionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pluginversion.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PluginVersionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pluginversion.FieldDeletedAt)
}

// SetVersion sets the "version" field.
func (m *PluginVersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PluginVersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PluginVersion entity.
// If the PluginVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PluginVersionMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *PluginVersionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PluginVersionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PluginVersion entity.
// If the PluginVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PluginVersionMutation) ResetDescription() {
	m.description = nil
}

// SetBroken sets the "broken" field.
func (m *PluginVersionMutation) SetBroken(b bool) {
	m.broken = &b
}

// Broken returns the value of the "broken" field in the mutation.
func (m *PluginVersionMutation) Broken() (r bool, exists bool) {
	v := m.broken
	if v == nil {
		return
	}
	return *v, true
}

// OldBroken returns the old "broken" field's value of the PluginVersion entity.
// If the PluginVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionMutation) OldBroken(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBroken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBroken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBroken: %w", err)
	}
	return oldValue.Broken, nil
}

// ResetBroken resets all changes to the "broken" field.
func (m *PluginVersionMutation) ResetBroken() {
	m.broken = nil
}

// SetPluginID sets the "plugin" edge to the Plugin entity by id.
func (m *PluginVersionMutation) SetPluginID(id uuid.UUID) {
	m.plugin = &id
}

// ClearPlugin clears the "plugin" edge to the Plugin entity.
func (m *PluginVersionMutation) ClearPlugin() {
	m.clearedplugin = true
}

// PluginCleared reports if the "plugin" edge to the Plugin entity was cleared.
func (m *PluginVersionMutation) PluginCleared() bool {
	return m.clearedplugin
}

// PluginID returns the "plugin" edge ID in the mutation.
func (m *PluginVersionMutation) PluginID() (id uuid.UUID, exists bool) {
	if m.plugin != nil {
		return *m.plugin, true
	}
	return
}

// PluginIDs returns the "plugin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PluginID instead. It exists only for internal usage by the builders.
func (m *PluginVersionMutation) PluginIDs() (ids []uuid.UUID) {
	if id := m.plugin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlugin resets all changes to the "plugin" edge.
func (m *PluginVersionMutation) ResetPlugin() {
	m.plugin = nil
	m.clearedplugin = false
}

// Where appends a list predicates to the PluginVersionMutation builder.
func (m *PluginVersionMutation) Where(ps ...predicate.PluginVersion) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PluginVersionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PluginVersion).
func (m *PluginVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PluginVersionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, pluginversion.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pluginversion.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pluginversion.FieldDeletedAt)
	}
	if m.version != nil {
		fields = append(fields, pluginversion.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, pluginversion.FieldDescription)
	}
	if m.broken != nil {
		fields = append(fields, pluginversion.FieldBroken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PluginVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pluginversion.FieldCreatedAt:
		return m.CreatedAt()
	case pluginversion.FieldUpdatedAt:
		return m.UpdatedAt()
	case pluginversion.FieldDeletedAt:
		return m.DeletedAt()
	case pluginversion.FieldVersion:
		return m.Version()
	case pluginversion.FieldDescription:
		return m.Description()
	case pluginversion.FieldBroken:
		return m.Broken()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PluginVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pluginversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pluginversion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pluginversion.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pluginversion.FieldVersion:
		return m.OldVersion(ctx)
	case pluginversion.FieldDescription:
		return m.OldDescription(ctx)
	case pluginversion.FieldBroken:
		return m.OldBroken(ctx)
	}
	return nil, fmt.Errorf("unknown PluginVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pluginversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pluginversion.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pluginversion.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pluginversion.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case pluginversion.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case pluginversion.FieldBroken:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBroken(v)
		return nil
	}
	return fmt.Errorf("unknown PluginVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PluginVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PluginVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PluginVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PluginVersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pluginversion.FieldDeletedAt) {
		fields = append(fields, pluginversion.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PluginVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PluginVersionMutation) ClearField(name string) error {
	switch name {
	case pluginversion.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PluginVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PluginVersionMutation) ResetField(name string) error {
	switch name {
	case pluginversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pluginversion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pluginversion.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pluginversion.FieldVersion:
		m.ResetVersion()
		return nil
	case pluginversion.FieldDescription:
		m.ResetDescription()
		return nil
	case pluginversion.FieldBroken:
		m.ResetBroken()
		return nil
	}
	return fmt.Errorf("unknown PluginVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PluginVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.plugin != nil {
		edges = append(edges, pluginversion.EdgePlugin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PluginVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pluginversion.EdgePlugin:
		if id := m.plugin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PluginVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PluginVersionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PluginVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplugin {
		edges = append(edges, pluginversion.EdgePlugin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PluginVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case pluginversion.EdgePlugin:
		return m.clearedplugin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PluginVersionMutation) ClearEdge(name string) error {
	switch name {
	case pluginversion.EdgePlugin:
		m.ClearPlugin()
		return nil
	}
	return fmt.Errorf("unknown PluginVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PluginVersionMutation) ResetEdge(name string) error {
	switch name {
	case pluginversion.EdgePlugin:
		m.ResetPlugin()
		return nil
	}
	return fmt.Errorf("unknown PluginVersion edge %s", name)
}

// PluginVersionPropertyMutation represents an operation that mutates the PluginVersionProperty nodes in the graph.
type PluginVersionPropertyMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	name           *string
	_default       *string
	required       *bool
	_type          *pluginversionproperty.Type
	clearedFields  map[string]struct{}
	plugin         *uuid.UUID
	clearedplugin  bool
	version        *uuid.UUID
	clearedversion bool
	done           bool
	oldValue       func(context.Context) (*PluginVersionProperty, error)
	predicates     []predicate.PluginVersionProperty
}

var _ ent.Mutation = (*PluginVersionPropertyMutation)(nil)

// pluginversionpropertyOption allows management of the mutation configuration using functional options.
type pluginversionpropertyOption func(*PluginVersionPropertyMutation)

// newPluginVersionPropertyMutation creates new mutation for the PluginVersionProperty entity.
func newPluginVersionPropertyMutation(c config, op Op, opts ...pluginversionpropertyOption) *PluginVersionPropertyMutation {
	m := &PluginVersionPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypePluginVersionProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPluginVersionPropertyID sets the ID field of the mutation.
func withPluginVersionPropertyID(id uuid.UUID) pluginversionpropertyOption {
	return func(m *PluginVersionPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *PluginVersionProperty
		)
		m.oldValue = func(ctx context.Context) (*PluginVersionProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PluginVersionProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPluginVersionProperty sets the old PluginVersionProperty of the mutation.
func withPluginVersionProperty(node *PluginVersionProperty) pluginversionpropertyOption {
	return func(m *PluginVersionPropertyMutation) {
		m.oldValue = func(context.Context) (*PluginVersionProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PluginVersionPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PluginVersionPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PluginVersionProperty entities.
func (m *PluginVersionPropertyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PluginVersionPropertyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PluginVersionPropertyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PluginVersionProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PluginVersionPropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PluginVersionPropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PluginVersionProperty entity.
// If the PluginVersionProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionPropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PluginVersionPropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PluginVersionPropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PluginVersionPropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PluginVersionProperty entity.
// If the PluginVersionProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionPropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PluginVersionPropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PluginVersionPropertyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PluginVersionPropertyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PluginVersionProperty entity.
// If the PluginVersionProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionPropertyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PluginVersionPropertyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pluginversionproperty.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PluginVersionPropertyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pluginversionproperty.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PluginVersionPropertyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pluginversionproperty.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *PluginVersionPropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PluginVersionPropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PluginVersionProperty entity.
// If the PluginVersionProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionPropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PluginVersionPropertyMutation) ResetName() {
	m.name = nil
}

// SetDefault sets the "default" field.
func (m *PluginVersionPropertyMutation) SetDefault(s string) {
	m._default = &s
}

// Default returns the value of the "default" field in the mutation.
func (m *PluginVersionPropertyMutation) Default() (r string, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the PluginVersionProperty entity.
// If the PluginVersionProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionPropertyMutation) OldDefault(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *PluginVersionPropertyMutation) ResetDefault() {
	m._default = nil
}

// SetRequired sets the "required" field.
func (m *PluginVersionPropertyMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *PluginVersionPropertyMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the PluginVersionProperty entity.
// If the PluginVersionProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionPropertyMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *PluginVersionPropertyMutation) ResetRequired() {
	m.required = nil
}

// SetType sets the "type" field.
func (m *PluginVersionPropertyMutation) SetType(pl pluginversionproperty.Type) {
	m._type = &pl
}

// GetType returns the value of the "type" field in the mutation.
func (m *PluginVersionPropertyMutation) GetType() (r pluginversionproperty.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PluginVersionProperty entity.
// If the PluginVersionProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PluginVersionPropertyMutation) OldType(ctx context.Context) (v pluginversionproperty.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PluginVersionPropertyMutation) ResetType() {
	m._type = nil
}

// SetPluginID sets the "plugin" edge to the Plugin entity by id.
func (m *PluginVersionPropertyMutation) SetPluginID(id uuid.UUID) {
	m.plugin = &id
}

// ClearPlugin clears the "plugin" edge to the Plugin entity.
func (m *PluginVersionPropertyMutation) ClearPlugin() {
	m.clearedplugin = true
}

// PluginCleared reports if the "plugin" edge to the Plugin entity was cleared.
func (m *PluginVersionPropertyMutation) PluginCleared() bool {
	return m.clearedplugin
}

// PluginID returns the "plugin" edge ID in the mutation.
func (m *PluginVersionPropertyMutation) PluginID() (id uuid.UUID, exists bool) {
	if m.plugin != nil {
		return *m.plugin, true
	}
	return
}

// PluginIDs returns the "plugin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PluginID instead. It exists only for internal usage by the builders.
func (m *PluginVersionPropertyMutation) PluginIDs() (ids []uuid.UUID) {
	if id := m.plugin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlugin resets all changes to the "plugin" edge.
func (m *PluginVersionPropertyMutation) ResetPlugin() {
	m.plugin = nil
	m.clearedplugin = false
}

// SetVersionID sets the "version" edge to the PluginVersion entity by id.
func (m *PluginVersionPropertyMutation) SetVersionID(id uuid.UUID) {
	m.version = &id
}

// ClearVersion clears the "version" edge to the PluginVersion entity.
func (m *PluginVersionPropertyMutation) ClearVersion() {
	m.clearedversion = true
}

// VersionCleared reports if the "version" edge to the PluginVersion entity was cleared.
func (m *PluginVersionPropertyMutation) VersionCleared() bool {
	return m.clearedversion
}

// VersionID returns the "version" edge ID in the mutation.
func (m *PluginVersionPropertyMutation) VersionID() (id uuid.UUID, exists bool) {
	if m.version != nil {
		return *m.version, true
	}
	return
}

// VersionIDs returns the "version" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VersionID instead. It exists only for internal usage by the builders.
func (m *PluginVersionPropertyMutation) VersionIDs() (ids []uuid.UUID) {
	if id := m.version; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVersion resets all changes to the "version" edge.
func (m *PluginVersionPropertyMutation) ResetVersion() {
	m.version = nil
	m.clearedversion = false
}

// Where appends a list predicates to the PluginVersionPropertyMutation builder.
func (m *PluginVersionPropertyMutation) Where(ps ...predicate.PluginVersionProperty) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PluginVersionPropertyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PluginVersionProperty).
func (m *PluginVersionPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PluginVersionPropertyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, pluginversionproperty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pluginversionproperty.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pluginversionproperty.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, pluginversionproperty.FieldName)
	}
	if m._default != nil {
		fields = append(fields, pluginversionproperty.FieldDefault)
	}
	if m.required != nil {
		fields = append(fields, pluginversionproperty.FieldRequired)
	}
	if m._type != nil {
		fields = append(fields, pluginversionproperty.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PluginVersionPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pluginversionproperty.FieldCreatedAt:
		return m.CreatedAt()
	case pluginversionproperty.FieldUpdatedAt:
		return m.UpdatedAt()
	case pluginversionproperty.FieldDeletedAt:
		return m.DeletedAt()
	case pluginversionproperty.FieldName:
		return m.Name()
	case pluginversionproperty.FieldDefault:
		return m.Default()
	case pluginversionproperty.FieldRequired:
		return m.Required()
	case pluginversionproperty.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PluginVersionPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pluginversionproperty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pluginversionproperty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pluginversionproperty.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pluginversionproperty.FieldName:
		return m.OldName(ctx)
	case pluginversionproperty.FieldDefault:
		return m.OldDefault(ctx)
	case pluginversionproperty.FieldRequired:
		return m.OldRequired(ctx)
	case pluginversionproperty.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown PluginVersionProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginVersionPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pluginversionproperty.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pluginversionproperty.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pluginversionproperty.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pluginversionproperty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pluginversionproperty.FieldDefault:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	case pluginversionproperty.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case pluginversionproperty.FieldType:
		v, ok := value.(pluginversionproperty.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown PluginVersionProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PluginVersionPropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PluginVersionPropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PluginVersionPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PluginVersionProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PluginVersionPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pluginversionproperty.FieldDeletedAt) {
		fields = append(fields, pluginversionproperty.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PluginVersionPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PluginVersionPropertyMutation) ClearField(name string) error {
	switch name {
	case pluginversionproperty.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PluginVersionProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PluginVersionPropertyMutation) ResetField(name string) error {
	switch name {
	case pluginversionproperty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pluginversionproperty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pluginversionproperty.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pluginversionproperty.FieldName:
		m.ResetName()
		return nil
	case pluginversionproperty.FieldDefault:
		m.ResetDefault()
		return nil
	case pluginversionproperty.FieldRequired:
		m.ResetRequired()
		return nil
	case pluginversionproperty.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown PluginVersionProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PluginVersionPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.plugin != nil {
		edges = append(edges, pluginversionproperty.EdgePlugin)
	}
	if m.version != nil {
		edges = append(edges, pluginversionproperty.EdgeVersion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PluginVersionPropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pluginversionproperty.EdgePlugin:
		if id := m.plugin; id != nil {
			return []ent.Value{*id}
		}
	case pluginversionproperty.EdgeVersion:
		if id := m.version; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PluginVersionPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PluginVersionPropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PluginVersionPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplugin {
		edges = append(edges, pluginversionproperty.EdgePlugin)
	}
	if m.clearedversion {
		edges = append(edges, pluginversionproperty.EdgeVersion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PluginVersionPropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case pluginversionproperty.EdgePlugin:
		return m.clearedplugin
	case pluginversionproperty.EdgeVersion:
		return m.clearedversion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PluginVersionPropertyMutation) ClearEdge(name string) error {
	switch name {
	case pluginversionproperty.EdgePlugin:
		m.ClearPlugin()
		return nil
	case pluginversionproperty.EdgeVersion:
		m.ClearVersion()
		return nil
	}
	return fmt.Errorf("unknown PluginVersionProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PluginVersionPropertyMutation) ResetEdge(name string) error {
	switch name {
	case pluginversionproperty.EdgePlugin:
		m.ResetPlugin()
		return nil
	case pluginversionproperty.EdgeVersion:
		m.ResetVersion()
		return nil
	}
	return fmt.Errorf("unknown PluginVersionProperty edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	code                   *string
	name                   *string
	_Description           *string
	_type                  *project.Type
	clearedFields          map[string]struct{}
	storages               map[uuid.UUID]struct{}
	removedstorages        map[uuid.UUID]struct{}
	clearedstorages        bool
	master_storage         *uuid.UUID
	clearedmaster_storage  bool
	develop_storage        *uuid.UUID
	cleareddevelop_storage bool
	done                   bool
	oldValue               func(context.Context) (*Project, error)
	predicates             []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uuid.UUID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProjectMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[project.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, project.FieldDeletedAt)
}

// SetCode sets the "code" field.
func (m *ProjectMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ProjectMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ProjectMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "Description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *ProjectMutation) ResetDescription() {
	m._Description = nil
}

// SetType sets the "type" field.
func (m *ProjectMutation) SetType(pr project.Type) {
	m._type = &pr
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProjectMutation) GetType() (r project.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldType(ctx context.Context) (v project.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProjectMutation) ResetType() {
	m._type = nil
}

// AddStorageIDs adds the "storages" edge to the Storage entity by ids.
func (m *ProjectMutation) AddStorageIDs(ids ...uuid.UUID) {
	if m.storages == nil {
		m.storages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.storages[ids[i]] = struct{}{}
	}
}

// ClearStorages clears the "storages" edge to the Storage entity.
func (m *ProjectMutation) ClearStorages() {
	m.clearedstorages = true
}

// StoragesCleared reports if the "storages" edge to the Storage entity was cleared.
func (m *ProjectMutation) StoragesCleared() bool {
	return m.clearedstorages
}

// RemoveStorageIDs removes the "storages" edge to the Storage entity by IDs.
func (m *ProjectMutation) RemoveStorageIDs(ids ...uuid.UUID) {
	if m.removedstorages == nil {
		m.removedstorages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.storages, ids[i])
		m.removedstorages[ids[i]] = struct{}{}
	}
}

// RemovedStorages returns the removed IDs of the "storages" edge to the Storage entity.
func (m *ProjectMutation) RemovedStoragesIDs() (ids []uuid.UUID) {
	for id := range m.removedstorages {
		ids = append(ids, id)
	}
	return
}

// StoragesIDs returns the "storages" edge IDs in the mutation.
func (m *ProjectMutation) StoragesIDs() (ids []uuid.UUID) {
	for id := range m.storages {
		ids = append(ids, id)
	}
	return
}

// ResetStorages resets all changes to the "storages" edge.
func (m *ProjectMutation) ResetStorages() {
	m.storages = nil
	m.clearedstorages = false
	m.removedstorages = nil
}

// SetMasterStorageID sets the "master_storage" edge to the Storage entity by id.
func (m *ProjectMutation) SetMasterStorageID(id uuid.UUID) {
	m.master_storage = &id
}

// ClearMasterStorage clears the "master_storage" edge to the Storage entity.
func (m *ProjectMutation) ClearMasterStorage() {
	m.clearedmaster_storage = true
}

// MasterStorageCleared reports if the "master_storage" edge to the Storage entity was cleared.
func (m *ProjectMutation) MasterStorageCleared() bool {
	return m.clearedmaster_storage
}

// MasterStorageID returns the "master_storage" edge ID in the mutation.
func (m *ProjectMutation) MasterStorageID() (id uuid.UUID, exists bool) {
	if m.master_storage != nil {
		return *m.master_storage, true
	}
	return
}

// MasterStorageIDs returns the "master_storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MasterStorageID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) MasterStorageIDs() (ids []uuid.UUID) {
	if id := m.master_storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMasterStorage resets all changes to the "master_storage" edge.
func (m *ProjectMutation) ResetMasterStorage() {
	m.master_storage = nil
	m.clearedmaster_storage = false
}

// SetDevelopStorageID sets the "develop_storage" edge to the Storage entity by id.
func (m *ProjectMutation) SetDevelopStorageID(id uuid.UUID) {
	m.develop_storage = &id
}

// ClearDevelopStorage clears the "develop_storage" edge to the Storage entity.
func (m *ProjectMutation) ClearDevelopStorage() {
	m.cleareddevelop_storage = true
}

// DevelopStorageCleared reports if the "develop_storage" edge to the Storage entity was cleared.
func (m *ProjectMutation) DevelopStorageCleared() bool {
	return m.cleareddevelop_storage
}

// DevelopStorageID returns the "develop_storage" edge ID in the mutation.
func (m *ProjectMutation) DevelopStorageID() (id uuid.UUID, exists bool) {
	if m.develop_storage != nil {
		return *m.develop_storage, true
	}
	return
}

// DevelopStorageIDs returns the "develop_storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DevelopStorageID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) DevelopStorageIDs() (ids []uuid.UUID) {
	if id := m.develop_storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevelopStorage resets all changes to the "develop_storage" edge.
func (m *ProjectMutation) ResetDevelopStorage() {
	m.develop_storage = nil
	m.cleareddevelop_storage = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.code != nil {
		fields = append(fields, project.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, project.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldCode:
		return m.Code()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldCode:
		return m.OldCode(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldType:
		v, ok := value.(project.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDeletedAt) {
		fields = append(fields, project.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldCode:
		m.ResetCode()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.storages != nil {
		edges = append(edges, project.EdgeStorages)
	}
	if m.master_storage != nil {
		edges = append(edges, project.EdgeMasterStorage)
	}
	if m.develop_storage != nil {
		edges = append(edges, project.EdgeDevelopStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeStorages:
		ids := make([]ent.Value, 0, len(m.storages))
		for id := range m.storages {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeMasterStorage:
		if id := m.master_storage; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeDevelopStorage:
		if id := m.develop_storage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstorages != nil {
		edges = append(edges, project.EdgeStorages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeStorages:
		ids := make([]ent.Value, 0, len(m.removedstorages))
		for id := range m.removedstorages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstorages {
		edges = append(edges, project.EdgeStorages)
	}
	if m.clearedmaster_storage {
		edges = append(edges, project.EdgeMasterStorage)
	}
	if m.cleareddevelop_storage {
		edges = append(edges, project.EdgeDevelopStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeStorages:
		return m.clearedstorages
	case project.EdgeMasterStorage:
		return m.clearedmaster_storage
	case project.EdgeDevelopStorage:
		return m.cleareddevelop_storage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeMasterStorage:
		m.ClearMasterStorage()
		return nil
	case project.EdgeDevelopStorage:
		m.ClearDevelopStorage()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeStorages:
		m.ResetStorages()
		return nil
	case project.EdgeMasterStorage:
		m.ResetMasterStorage()
		return nil
	case project.EdgeDevelopStorage:
		m.ResetDevelopStorage()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// StorageMutation represents an operation that mutates the Storage nodes in the graph.
type StorageMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	connection_string *string
	develop           *bool
	extension         *string
	_type             *storage.Type
	clearedFields     map[string]struct{}
	project           *uuid.UUID
	clearedproject    bool
	parent            *uuid.UUID
	clearedparent     bool
	done              bool
	oldValue          func(context.Context) (*Storage, error)
	predicates        []predicate.Storage
}

var _ ent.Mutation = (*StorageMutation)(nil)

// storageOption allows management of the mutation configuration using functional options.
type storageOption func(*StorageMutation)

// newStorageMutation creates new mutation for the Storage entity.
func newStorageMutation(c config, op Op, opts ...storageOption) *StorageMutation {
	m := &StorageMutation{
		config:        c,
		op:            op,
		typ:           TypeStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStorageID sets the ID field of the mutation.
func withStorageID(id uuid.UUID) storageOption {
	return func(m *StorageMutation) {
		var (
			err   error
			once  sync.Once
			value *Storage
		)
		m.oldValue = func(ctx context.Context) (*Storage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Storage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStorage sets the old Storage of the mutation.
func withStorage(node *Storage) storageOption {
	return func(m *StorageMutation) {
		m.oldValue = func(context.Context) (*Storage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Storage entities.
func (m *StorageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StorageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StorageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Storage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StorageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StorageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StorageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StorageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StorageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StorageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StorageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StorageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StorageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[storage.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StorageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[storage.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StorageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, storage.FieldDeletedAt)
}

// SetConnectionString sets the "connection_string" field.
func (m *StorageMutation) SetConnectionString(s string) {
	m.connection_string = &s
}

// ConnectionString returns the value of the "connection_string" field in the mutation.
func (m *StorageMutation) ConnectionString() (r string, exists bool) {
	v := m.connection_string
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionString returns the old "connection_string" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldConnectionString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionString: %w", err)
	}
	return oldValue.ConnectionString, nil
}

// ResetConnectionString resets all changes to the "connection_string" field.
func (m *StorageMutation) ResetConnectionString() {
	m.connection_string = nil
}

// SetDevelop sets the "develop" field.
func (m *StorageMutation) SetDevelop(b bool) {
	m.develop = &b
}

// Develop returns the value of the "develop" field in the mutation.
func (m *StorageMutation) Develop() (r bool, exists bool) {
	v := m.develop
	if v == nil {
		return
	}
	return *v, true
}

// OldDevelop returns the old "develop" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldDevelop(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevelop is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevelop requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevelop: %w", err)
	}
	return oldValue.Develop, nil
}

// ResetDevelop resets all changes to the "develop" field.
func (m *StorageMutation) ResetDevelop() {
	m.develop = nil
}

// SetExtension sets the "extension" field.
func (m *StorageMutation) SetExtension(s string) {
	m.extension = &s
}

// Extension returns the value of the "extension" field in the mutation.
func (m *StorageMutation) Extension() (r string, exists bool) {
	v := m.extension
	if v == nil {
		return
	}
	return *v, true
}

// OldExtension returns the old "extension" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldExtension(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtension: %w", err)
	}
	return oldValue.Extension, nil
}

// ClearExtension clears the value of the "extension" field.
func (m *StorageMutation) ClearExtension() {
	m.extension = nil
	m.clearedFields[storage.FieldExtension] = struct{}{}
}

// ExtensionCleared returns if the "extension" field was cleared in this mutation.
func (m *StorageMutation) ExtensionCleared() bool {
	_, ok := m.clearedFields[storage.FieldExtension]
	return ok
}

// ResetExtension resets all changes to the "extension" field.
func (m *StorageMutation) ResetExtension() {
	m.extension = nil
	delete(m.clearedFields, storage.FieldExtension)
}

// SetType sets the "type" field.
func (m *StorageMutation) SetType(s storage.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StorageMutation) GetType() (r storage.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldType(ctx context.Context) (v storage.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StorageMutation) ResetType() {
	m._type = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *StorageMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *StorageMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *StorageMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *StorageMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *StorageMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *StorageMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetParentID sets the "parent" edge to the Storage entity by id.
func (m *StorageMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Storage entity.
func (m *StorageMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Storage entity was cleared.
func (m *StorageMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *StorageMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *StorageMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *StorageMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the StorageMutation builder.
func (m *StorageMutation) Where(ps ...predicate.Storage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StorageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Storage).
func (m *StorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StorageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, storage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storage.FieldDeletedAt)
	}
	if m.connection_string != nil {
		fields = append(fields, storage.FieldConnectionString)
	}
	if m.develop != nil {
		fields = append(fields, storage.FieldDevelop)
	}
	if m.extension != nil {
		fields = append(fields, storage.FieldExtension)
	}
	if m._type != nil {
		fields = append(fields, storage.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storage.FieldCreatedAt:
		return m.CreatedAt()
	case storage.FieldUpdatedAt:
		return m.UpdatedAt()
	case storage.FieldDeletedAt:
		return m.DeletedAt()
	case storage.FieldConnectionString:
		return m.ConnectionString()
	case storage.FieldDevelop:
		return m.Develop()
	case storage.FieldExtension:
		return m.Extension()
	case storage.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storage.FieldConnectionString:
		return m.OldConnectionString(ctx)
	case storage.FieldDevelop:
		return m.OldDevelop(ctx)
	case storage.FieldExtension:
		return m.OldExtension(ctx)
	case storage.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Storage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storage.FieldConnectionString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionString(v)
		return nil
	case storage.FieldDevelop:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevelop(v)
		return nil
	case storage.FieldExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtension(v)
		return nil
	case storage.FieldType:
		v, ok := value.(storage.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Storage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StorageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StorageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Storage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StorageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storage.FieldDeletedAt) {
		fields = append(fields, storage.FieldDeletedAt)
	}
	if m.FieldCleared(storage.FieldExtension) {
		fields = append(fields, storage.FieldExtension)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StorageMutation) ClearField(name string) error {
	switch name {
	case storage.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case storage.FieldExtension:
		m.ClearExtension()
		return nil
	}
	return fmt.Errorf("unknown Storage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StorageMutation) ResetField(name string) error {
	switch name {
	case storage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storage.FieldConnectionString:
		m.ResetConnectionString()
		return nil
	case storage.FieldDevelop:
		m.ResetDevelop()
		return nil
	case storage.FieldExtension:
		m.ResetExtension()
		return nil
	case storage.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Storage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, storage.EdgeProject)
	}
	if m.parent != nil {
		edges = append(edges, storage.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StorageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storage.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case storage.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StorageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, storage.EdgeProject)
	}
	if m.clearedparent {
		edges = append(edges, storage.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StorageMutation) EdgeCleared(name string) bool {
	switch name {
	case storage.EdgeProject:
		return m.clearedproject
	case storage.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StorageMutation) ClearEdge(name string) error {
	switch name {
	case storage.EdgeProject:
		m.ClearProject()
		return nil
	case storage.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Storage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StorageMutation) ResetEdge(name string) error {
	switch name {
	case storage.EdgeProject:
		m.ResetProject()
		return nil
	case storage.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown Storage edge %s", name)
}

// StorageCommitMutation represents an operation that mutates the StorageCommit nodes in the graph.
type StorageCommitMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	number                *uint
	addnumber             *int
	configuration_version *string
	author                *string
	description           *string
	tag                   *string
	tag_description       *string
	commit_at             *time.Time
	clearedFields         map[string]struct{}
	storage               *uuid.UUID
	clearedstorage        bool
	done                  bool
	oldValue              func(context.Context) (*StorageCommit, error)
	predicates            []predicate.StorageCommit
}

var _ ent.Mutation = (*StorageCommitMutation)(nil)

// storagecommitOption allows management of the mutation configuration using functional options.
type storagecommitOption func(*StorageCommitMutation)

// newStorageCommitMutation creates new mutation for the StorageCommit entity.
func newStorageCommitMutation(c config, op Op, opts ...storagecommitOption) *StorageCommitMutation {
	m := &StorageCommitMutation{
		config:        c,
		op:            op,
		typ:           TypeStorageCommit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStorageCommitID sets the ID field of the mutation.
func withStorageCommitID(id uuid.UUID) storagecommitOption {
	return func(m *StorageCommitMutation) {
		var (
			err   error
			once  sync.Once
			value *StorageCommit
		)
		m.oldValue = func(ctx context.Context) (*StorageCommit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StorageCommit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStorageCommit sets the old StorageCommit of the mutation.
func withStorageCommit(node *StorageCommit) storagecommitOption {
	return func(m *StorageCommitMutation) {
		m.oldValue = func(context.Context) (*StorageCommit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StorageCommitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StorageCommitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StorageCommit entities.
func (m *StorageCommitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StorageCommitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StorageCommitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StorageCommit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StorageCommitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StorageCommitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StorageCommitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StorageCommitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StorageCommitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StorageCommitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StorageCommitMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StorageCommitMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StorageCommitMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[storagecommit.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StorageCommitMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[storagecommit.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StorageCommitMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, storagecommit.FieldDeletedAt)
}

// SetNumber sets the "number" field.
func (m *StorageCommitMutation) SetNumber(u uint) {
	m.number = &u
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *StorageCommitMutation) Number() (r uint, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldNumber(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds u to the "number" field.
func (m *StorageCommitMutation) AddNumber(u int) {
	if m.addnumber != nil {
		*m.addnumber += u
	} else {
		m.addnumber = &u
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *StorageCommitMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *StorageCommitMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetConfigurationVersion sets the "configuration_version" field.
func (m *StorageCommitMutation) SetConfigurationVersion(s string) {
	m.configuration_version = &s
}

// ConfigurationVersion returns the value of the "configuration_version" field in the mutation.
func (m *StorageCommitMutation) ConfigurationVersion() (r string, exists bool) {
	v := m.configuration_version
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigurationVersion returns the old "configuration_version" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldConfigurationVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigurationVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigurationVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigurationVersion: %w", err)
	}
	return oldValue.ConfigurationVersion, nil
}

// ResetConfigurationVersion resets all changes to the "configuration_version" field.
func (m *StorageCommitMutation) ResetConfigurationVersion() {
	m.configuration_version = nil
}

// SetAuthor sets the "author" field.
func (m *StorageCommitMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *StorageCommitMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *StorageCommitMutation) ResetAuthor() {
	m.author = nil
}

// SetDescription sets the "description" field.
func (m *StorageCommitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StorageCommitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *StorageCommitMutation) ResetDescription() {
	m.description = nil
}

// SetTag sets the "tag" field.
func (m *StorageCommitMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *StorageCommitMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *StorageCommitMutation) ResetTag() {
	m.tag = nil
}

// SetTagDescription sets the "tag_description" field.
func (m *StorageCommitMutation) SetTagDescription(s string) {
	m.tag_description = &s
}

// TagDescription returns the value of the "tag_description" field in the mutation.
func (m *StorageCommitMutation) TagDescription() (r string, exists bool) {
	v := m.tag_description
	if v == nil {
		return
	}
	return *v, true
}

// OldTagDescription returns the old "tag_description" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldTagDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagDescription: %w", err)
	}
	return oldValue.TagDescription, nil
}

// ResetTagDescription resets all changes to the "tag_description" field.
func (m *StorageCommitMutation) ResetTagDescription() {
	m.tag_description = nil
}

// SetCommitAt sets the "commit_at" field.
func (m *StorageCommitMutation) SetCommitAt(t time.Time) {
	m.commit_at = &t
}

// CommitAt returns the value of the "commit_at" field in the mutation.
func (m *StorageCommitMutation) CommitAt() (r time.Time, exists bool) {
	v := m.commit_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitAt returns the old "commit_at" field's value of the StorageCommit entity.
// If the StorageCommit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageCommitMutation) OldCommitAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitAt: %w", err)
	}
	return oldValue.CommitAt, nil
}

// ResetCommitAt resets all changes to the "commit_at" field.
func (m *StorageCommitMutation) ResetCommitAt() {
	m.commit_at = nil
}

// SetStorageID sets the "storage" edge to the Storage entity by id.
func (m *StorageCommitMutation) SetStorageID(id uuid.UUID) {
	m.storage = &id
}

// ClearStorage clears the "storage" edge to the Storage entity.
func (m *StorageCommitMutation) ClearStorage() {
	m.clearedstorage = true
}

// StorageCleared reports if the "storage" edge to the Storage entity was cleared.
func (m *StorageCommitMutation) StorageCleared() bool {
	return m.clearedstorage
}

// StorageID returns the "storage" edge ID in the mutation.
func (m *StorageCommitMutation) StorageID() (id uuid.UUID, exists bool) {
	if m.storage != nil {
		return *m.storage, true
	}
	return
}

// StorageIDs returns the "storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StorageID instead. It exists only for internal usage by the builders.
func (m *StorageCommitMutation) StorageIDs() (ids []uuid.UUID) {
	if id := m.storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStorage resets all changes to the "storage" edge.
func (m *StorageCommitMutation) ResetStorage() {
	m.storage = nil
	m.clearedstorage = false
}

// Where appends a list predicates to the StorageCommitMutation builder.
func (m *StorageCommitMutation) Where(ps ...predicate.StorageCommit) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StorageCommitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StorageCommit).
func (m *StorageCommitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StorageCommitMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, storagecommit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storagecommit.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storagecommit.FieldDeletedAt)
	}
	if m.number != nil {
		fields = append(fields, storagecommit.FieldNumber)
	}
	if m.configuration_version != nil {
		fields = append(fields, storagecommit.FieldConfigurationVersion)
	}
	if m.author != nil {
		fields = append(fields, storagecommit.FieldAuthor)
	}
	if m.description != nil {
		fields = append(fields, storagecommit.FieldDescription)
	}
	if m.tag != nil {
		fields = append(fields, storagecommit.FieldTag)
	}
	if m.tag_description != nil {
		fields = append(fields, storagecommit.FieldTagDescription)
	}
	if m.commit_at != nil {
		fields = append(fields, storagecommit.FieldCommitAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StorageCommitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storagecommit.FieldCreatedAt:
		return m.CreatedAt()
	case storagecommit.FieldUpdatedAt:
		return m.UpdatedAt()
	case storagecommit.FieldDeletedAt:
		return m.DeletedAt()
	case storagecommit.FieldNumber:
		return m.Number()
	case storagecommit.FieldConfigurationVersion:
		return m.ConfigurationVersion()
	case storagecommit.FieldAuthor:
		return m.Author()
	case storagecommit.FieldDescription:
		return m.Description()
	case storagecommit.FieldTag:
		return m.Tag()
	case storagecommit.FieldTagDescription:
		return m.TagDescription()
	case storagecommit.FieldCommitAt:
		return m.CommitAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StorageCommitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storagecommit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storagecommit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storagecommit.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storagecommit.FieldNumber:
		return m.OldNumber(ctx)
	case storagecommit.FieldConfigurationVersion:
		return m.OldConfigurationVersion(ctx)
	case storagecommit.FieldAuthor:
		return m.OldAuthor(ctx)
	case storagecommit.FieldDescription:
		return m.OldDescription(ctx)
	case storagecommit.FieldTag:
		return m.OldTag(ctx)
	case storagecommit.FieldTagDescription:
		return m.OldTagDescription(ctx)
	case storagecommit.FieldCommitAt:
		return m.OldCommitAt(ctx)
	}
	return nil, fmt.Errorf("unknown StorageCommit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageCommitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storagecommit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storagecommit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storagecommit.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storagecommit.FieldNumber:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case storagecommit.FieldConfigurationVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigurationVersion(v)
		return nil
	case storagecommit.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case storagecommit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case storagecommit.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case storagecommit.FieldTagDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagDescription(v)
		return nil
	case storagecommit.FieldCommitAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitAt(v)
		return nil
	}
	return fmt.Errorf("unknown StorageCommit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StorageCommitMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, storagecommit.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StorageCommitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storagecommit.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageCommitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storagecommit.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown StorageCommit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StorageCommitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storagecommit.FieldDeletedAt) {
		fields = append(fields, storagecommit.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StorageCommitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StorageCommitMutation) ClearField(name string) error {
	switch name {
	case storagecommit.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown StorageCommit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StorageCommitMutation) ResetField(name string) error {
	switch name {
	case storagecommit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storagecommit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storagecommit.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storagecommit.FieldNumber:
		m.ResetNumber()
		return nil
	case storagecommit.FieldConfigurationVersion:
		m.ResetConfigurationVersion()
		return nil
	case storagecommit.FieldAuthor:
		m.ResetAuthor()
		return nil
	case storagecommit.FieldDescription:
		m.ResetDescription()
		return nil
	case storagecommit.FieldTag:
		m.ResetTag()
		return nil
	case storagecommit.FieldTagDescription:
		m.ResetTagDescription()
		return nil
	case storagecommit.FieldCommitAt:
		m.ResetCommitAt()
		return nil
	}
	return fmt.Errorf("unknown StorageCommit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StorageCommitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.storage != nil {
		edges = append(edges, storagecommit.EdgeStorage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StorageCommitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storagecommit.EdgeStorage:
		if id := m.storage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StorageCommitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StorageCommitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StorageCommitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstorage {
		edges = append(edges, storagecommit.EdgeStorage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StorageCommitMutation) EdgeCleared(name string) bool {
	switch name {
	case storagecommit.EdgeStorage:
		return m.clearedstorage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StorageCommitMutation) ClearEdge(name string) error {
	switch name {
	case storagecommit.EdgeStorage:
		m.ClearStorage()
		return nil
	}
	return fmt.Errorf("unknown StorageCommit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StorageCommitMutation) ResetEdge(name string) error {
	switch name {
	case storagecommit.EdgeStorage:
		m.ResetStorage()
		return nil
	}
	return fmt.Errorf("unknown StorageCommit edge %s", name)
}

// StoragePluginMutation represents an operation that mutates the StoragePlugin nodes in the graph.
type StoragePluginMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	disable           *bool
	clearedFields     map[string]struct{}
	storage           *uuid.UUID
	clearedstorage    bool
	plugin            *uuid.UUID
	clearedplugin     bool
	properties        map[uuid.UUID]struct{}
	removedproperties map[uuid.UUID]struct{}
	clearedproperties bool
	done              bool
	oldValue          func(context.Context) (*StoragePlugin, error)
	predicates        []predicate.StoragePlugin
}

var _ ent.Mutation = (*StoragePluginMutation)(nil)

// storagepluginOption allows management of the mutation configuration using functional options.
type storagepluginOption func(*StoragePluginMutation)

// newStoragePluginMutation creates new mutation for the StoragePlugin entity.
func newStoragePluginMutation(c config, op Op, opts ...storagepluginOption) *StoragePluginMutation {
	m := &StoragePluginMutation{
		config:        c,
		op:            op,
		typ:           TypeStoragePlugin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoragePluginID sets the ID field of the mutation.
func withStoragePluginID(id uuid.UUID) storagepluginOption {
	return func(m *StoragePluginMutation) {
		var (
			err   error
			once  sync.Once
			value *StoragePlugin
		)
		m.oldValue = func(ctx context.Context) (*StoragePlugin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoragePlugin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoragePlugin sets the old StoragePlugin of the mutation.
func withStoragePlugin(node *StoragePlugin) storagepluginOption {
	return func(m *StoragePluginMutation) {
		m.oldValue = func(context.Context) (*StoragePlugin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoragePluginMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoragePluginMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoragePlugin entities.
func (m *StoragePluginMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoragePluginMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoragePluginMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoragePlugin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoragePluginMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoragePluginMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoragePlugin entity.
// If the StoragePlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoragePluginMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoragePluginMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoragePluginMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoragePlugin entity.
// If the StoragePlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoragePluginMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoragePluginMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoragePluginMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoragePlugin entity.
// If the StoragePlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoragePluginMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[storageplugin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoragePluginMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[storageplugin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoragePluginMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, storageplugin.FieldDeletedAt)
}

// SetDisable sets the "disable" field.
func (m *StoragePluginMutation) SetDisable(b bool) {
	m.disable = &b
}

// Disable returns the value of the "disable" field in the mutation.
func (m *StoragePluginMutation) Disable() (r bool, exists bool) {
	v := m.disable
	if v == nil {
		return
	}
	return *v, true
}

// OldDisable returns the old "disable" field's value of the StoragePlugin entity.
// If the StoragePlugin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginMutation) OldDisable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisable: %w", err)
	}
	return oldValue.Disable, nil
}

// ResetDisable resets all changes to the "disable" field.
func (m *StoragePluginMutation) ResetDisable() {
	m.disable = nil
}

// SetStorageID sets the "storage" edge to the Storage entity by id.
func (m *StoragePluginMutation) SetStorageID(id uuid.UUID) {
	m.storage = &id
}

// ClearStorage clears the "storage" edge to the Storage entity.
func (m *StoragePluginMutation) ClearStorage() {
	m.clearedstorage = true
}

// StorageCleared reports if the "storage" edge to the Storage entity was cleared.
func (m *StoragePluginMutation) StorageCleared() bool {
	return m.clearedstorage
}

// StorageID returns the "storage" edge ID in the mutation.
func (m *StoragePluginMutation) StorageID() (id uuid.UUID, exists bool) {
	if m.storage != nil {
		return *m.storage, true
	}
	return
}

// StorageIDs returns the "storage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StorageID instead. It exists only for internal usage by the builders.
func (m *StoragePluginMutation) StorageIDs() (ids []uuid.UUID) {
	if id := m.storage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStorage resets all changes to the "storage" edge.
func (m *StoragePluginMutation) ResetStorage() {
	m.storage = nil
	m.clearedstorage = false
}

// SetPluginID sets the "plugin" edge to the PluginVersion entity by id.
func (m *StoragePluginMutation) SetPluginID(id uuid.UUID) {
	m.plugin = &id
}

// ClearPlugin clears the "plugin" edge to the PluginVersion entity.
func (m *StoragePluginMutation) ClearPlugin() {
	m.clearedplugin = true
}

// PluginCleared reports if the "plugin" edge to the PluginVersion entity was cleared.
func (m *StoragePluginMutation) PluginCleared() bool {
	return m.clearedplugin
}

// PluginID returns the "plugin" edge ID in the mutation.
func (m *StoragePluginMutation) PluginID() (id uuid.UUID, exists bool) {
	if m.plugin != nil {
		return *m.plugin, true
	}
	return
}

// PluginIDs returns the "plugin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PluginID instead. It exists only for internal usage by the builders.
func (m *StoragePluginMutation) PluginIDs() (ids []uuid.UUID) {
	if id := m.plugin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlugin resets all changes to the "plugin" edge.
func (m *StoragePluginMutation) ResetPlugin() {
	m.plugin = nil
	m.clearedplugin = false
}

// AddPropertyIDs adds the "properties" edge to the StoragePluginProperty entity by ids.
func (m *StoragePluginMutation) AddPropertyIDs(ids ...uuid.UUID) {
	if m.properties == nil {
		m.properties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the StoragePluginProperty entity.
func (m *StoragePluginMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the StoragePluginProperty entity was cleared.
func (m *StoragePluginMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the StoragePluginProperty entity by IDs.
func (m *StoragePluginMutation) RemovePropertyIDs(ids ...uuid.UUID) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the StoragePluginProperty entity.
func (m *StoragePluginMutation) RemovedPropertiesIDs() (ids []uuid.UUID) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *StoragePluginMutation) PropertiesIDs() (ids []uuid.UUID) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *StoragePluginMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// Where appends a list predicates to the StoragePluginMutation builder.
func (m *StoragePluginMutation) Where(ps ...predicate.StoragePlugin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StoragePluginMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StoragePlugin).
func (m *StoragePluginMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoragePluginMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, storageplugin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storageplugin.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storageplugin.FieldDeletedAt)
	}
	if m.disable != nil {
		fields = append(fields, storageplugin.FieldDisable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoragePluginMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storageplugin.FieldCreatedAt:
		return m.CreatedAt()
	case storageplugin.FieldUpdatedAt:
		return m.UpdatedAt()
	case storageplugin.FieldDeletedAt:
		return m.DeletedAt()
	case storageplugin.FieldDisable:
		return m.Disable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoragePluginMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storageplugin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storageplugin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storageplugin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storageplugin.FieldDisable:
		return m.OldDisable(ctx)
	}
	return nil, fmt.Errorf("unknown StoragePlugin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePluginMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storageplugin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storageplugin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storageplugin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storageplugin.FieldDisable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisable(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePlugin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoragePluginMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoragePluginMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePluginMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StoragePlugin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoragePluginMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storageplugin.FieldDeletedAt) {
		fields = append(fields, storageplugin.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoragePluginMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoragePluginMutation) ClearField(name string) error {
	switch name {
	case storageplugin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown StoragePlugin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoragePluginMutation) ResetField(name string) error {
	switch name {
	case storageplugin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storageplugin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storageplugin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storageplugin.FieldDisable:
		m.ResetDisable()
		return nil
	}
	return fmt.Errorf("unknown StoragePlugin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoragePluginMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.storage != nil {
		edges = append(edges, storageplugin.EdgeStorage)
	}
	if m.plugin != nil {
		edges = append(edges, storageplugin.EdgePlugin)
	}
	if m.properties != nil {
		edges = append(edges, storageplugin.EdgeProperties)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoragePluginMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storageplugin.EdgeStorage:
		if id := m.storage; id != nil {
			return []ent.Value{*id}
		}
	case storageplugin.EdgePlugin:
		if id := m.plugin; id != nil {
			return []ent.Value{*id}
		}
	case storageplugin.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoragePluginMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproperties != nil {
		edges = append(edges, storageplugin.EdgeProperties)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoragePluginMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case storageplugin.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoragePluginMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstorage {
		edges = append(edges, storageplugin.EdgeStorage)
	}
	if m.clearedplugin {
		edges = append(edges, storageplugin.EdgePlugin)
	}
	if m.clearedproperties {
		edges = append(edges, storageplugin.EdgeProperties)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoragePluginMutation) EdgeCleared(name string) bool {
	switch name {
	case storageplugin.EdgeStorage:
		return m.clearedstorage
	case storageplugin.EdgePlugin:
		return m.clearedplugin
	case storageplugin.EdgeProperties:
		return m.clearedproperties
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoragePluginMutation) ClearEdge(name string) error {
	switch name {
	case storageplugin.EdgeStorage:
		m.ClearStorage()
		return nil
	case storageplugin.EdgePlugin:
		m.ClearPlugin()
		return nil
	}
	return fmt.Errorf("unknown StoragePlugin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoragePluginMutation) ResetEdge(name string) error {
	switch name {
	case storageplugin.EdgeStorage:
		m.ResetStorage()
		return nil
	case storageplugin.EdgePlugin:
		m.ResetPlugin()
		return nil
	case storageplugin.EdgeProperties:
		m.ResetProperties()
		return nil
	}
	return fmt.Errorf("unknown StoragePlugin edge %s", name)
}

// StoragePluginPropertyMutation represents an operation that mutates the StoragePluginProperty nodes in the graph.
type StoragePluginPropertyMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	name          *string
	value         *string
	clearedFields map[string]struct{}
	plugin        *uuid.UUID
	clearedplugin bool
	done          bool
	oldValue      func(context.Context) (*StoragePluginProperty, error)
	predicates    []predicate.StoragePluginProperty
}

var _ ent.Mutation = (*StoragePluginPropertyMutation)(nil)

// storagepluginpropertyOption allows management of the mutation configuration using functional options.
type storagepluginpropertyOption func(*StoragePluginPropertyMutation)

// newStoragePluginPropertyMutation creates new mutation for the StoragePluginProperty entity.
func newStoragePluginPropertyMutation(c config, op Op, opts ...storagepluginpropertyOption) *StoragePluginPropertyMutation {
	m := &StoragePluginPropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeStoragePluginProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoragePluginPropertyID sets the ID field of the mutation.
func withStoragePluginPropertyID(id uuid.UUID) storagepluginpropertyOption {
	return func(m *StoragePluginPropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *StoragePluginProperty
		)
		m.oldValue = func(ctx context.Context) (*StoragePluginProperty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoragePluginProperty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoragePluginProperty sets the old StoragePluginProperty of the mutation.
func withStoragePluginProperty(node *StoragePluginProperty) storagepluginpropertyOption {
	return func(m *StoragePluginPropertyMutation) {
		m.oldValue = func(context.Context) (*StoragePluginProperty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoragePluginPropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoragePluginPropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoragePluginProperty entities.
func (m *StoragePluginPropertyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoragePluginPropertyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoragePluginPropertyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoragePluginProperty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoragePluginPropertyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoragePluginPropertyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoragePluginProperty entity.
// If the StoragePluginProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginPropertyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoragePluginPropertyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoragePluginPropertyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoragePluginPropertyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoragePluginProperty entity.
// If the StoragePluginProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginPropertyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoragePluginPropertyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoragePluginPropertyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoragePluginPropertyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the StoragePluginProperty entity.
// If the StoragePluginProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginPropertyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoragePluginPropertyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[storagepluginproperty.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoragePluginPropertyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[storagepluginproperty.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoragePluginPropertyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, storagepluginproperty.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *StoragePluginPropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoragePluginPropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StoragePluginProperty entity.
// If the StoragePluginProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginPropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoragePluginPropertyMutation) ResetName() {
	m.name = nil
}

// SetValue sets the "value" field.
func (m *StoragePluginPropertyMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *StoragePluginPropertyMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the StoragePluginProperty entity.
// If the StoragePluginProperty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoragePluginPropertyMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *StoragePluginPropertyMutation) ResetValue() {
	m.value = nil
}

// SetPluginID sets the "plugin" edge to the StoragePlugin entity by id.
func (m *StoragePluginPropertyMutation) SetPluginID(id uuid.UUID) {
	m.plugin = &id
}

// ClearPlugin clears the "plugin" edge to the StoragePlugin entity.
func (m *StoragePluginPropertyMutation) ClearPlugin() {
	m.clearedplugin = true
}

// PluginCleared reports if the "plugin" edge to the StoragePlugin entity was cleared.
func (m *StoragePluginPropertyMutation) PluginCleared() bool {
	return m.clearedplugin
}

// PluginID returns the "plugin" edge ID in the mutation.
func (m *StoragePluginPropertyMutation) PluginID() (id uuid.UUID, exists bool) {
	if m.plugin != nil {
		return *m.plugin, true
	}
	return
}

// PluginIDs returns the "plugin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PluginID instead. It exists only for internal usage by the builders.
func (m *StoragePluginPropertyMutation) PluginIDs() (ids []uuid.UUID) {
	if id := m.plugin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlugin resets all changes to the "plugin" edge.
func (m *StoragePluginPropertyMutation) ResetPlugin() {
	m.plugin = nil
	m.clearedplugin = false
}

// Where appends a list predicates to the StoragePluginPropertyMutation builder.
func (m *StoragePluginPropertyMutation) Where(ps ...predicate.StoragePluginProperty) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StoragePluginPropertyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StoragePluginProperty).
func (m *StoragePluginPropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoragePluginPropertyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, storagepluginproperty.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, storagepluginproperty.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, storagepluginproperty.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, storagepluginproperty.FieldName)
	}
	if m.value != nil {
		fields = append(fields, storagepluginproperty.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoragePluginPropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storagepluginproperty.FieldCreatedAt:
		return m.CreatedAt()
	case storagepluginproperty.FieldUpdatedAt:
		return m.UpdatedAt()
	case storagepluginproperty.FieldDeletedAt:
		return m.DeletedAt()
	case storagepluginproperty.FieldName:
		return m.Name()
	case storagepluginproperty.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoragePluginPropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storagepluginproperty.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storagepluginproperty.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storagepluginproperty.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case storagepluginproperty.FieldName:
		return m.OldName(ctx)
	case storagepluginproperty.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown StoragePluginProperty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePluginPropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storagepluginproperty.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storagepluginproperty.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storagepluginproperty.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case storagepluginproperty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storagepluginproperty.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown StoragePluginProperty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoragePluginPropertyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoragePluginPropertyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoragePluginPropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StoragePluginProperty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoragePluginPropertyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storagepluginproperty.FieldDeletedAt) {
		fields = append(fields, storagepluginproperty.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoragePluginPropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoragePluginPropertyMutation) ClearField(name string) error {
	switch name {
	case storagepluginproperty.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown StoragePluginProperty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoragePluginPropertyMutation) ResetField(name string) error {
	switch name {
	case storagepluginproperty.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storagepluginproperty.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storagepluginproperty.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case storagepluginproperty.FieldName:
		m.ResetName()
		return nil
	case storagepluginproperty.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown StoragePluginProperty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoragePluginPropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.plugin != nil {
		edges = append(edges, storagepluginproperty.EdgePlugin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoragePluginPropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storagepluginproperty.EdgePlugin:
		if id := m.plugin; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoragePluginPropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoragePluginPropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoragePluginPropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplugin {
		edges = append(edges, storagepluginproperty.EdgePlugin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoragePluginPropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case storagepluginproperty.EdgePlugin:
		return m.clearedplugin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoragePluginPropertyMutation) ClearEdge(name string) error {
	switch name {
	case storagepluginproperty.EdgePlugin:
		m.ClearPlugin()
		return nil
	}
	return fmt.Errorf("unknown StoragePluginProperty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoragePluginPropertyMutation) ResetEdge(name string) error {
	switch name {
	case storagepluginproperty.EdgePlugin:
		m.ResetPlugin()
		return nil
	}
	return fmt.Errorf("unknown StoragePluginProperty edge %s", name)
}
